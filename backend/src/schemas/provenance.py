"""
Provenance Schemas - Pydantic models for data provenance and lineage tracking.
Following W3C PROV standard for provenance representation.
"""

from datetime import datetime
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import BaseModel, Field, validator


class ProvenanceEntityCreate(BaseModel):
    """Create provenance entity request."""
    
    entity_type: str = Field(..., description="Type of entity (patient_data, protocol, model, etc.)")
    entity_id: str = Field(..., description="Unique identifier of the entity")
    attributes: Dict[str, Any] = Field({}, description="Entity attributes and properties")
    location: Optional[str] = Field(None, description="Location or URI of the entity")
    
    @validator("entity_type")
    def validate_entity_type(cls, v):
        allowed_types = [
            "patient_data", "clinical_protocol", "decision_result", "ai_model",
            "evidence_record", "guideline", "user_input", "system_configuration",
            "medication", "procedure", "diagnosis", "observation"
        ]
        if v not in allowed_types:
            raise ValueError(f"Entity type must be one of: {', '.join(allowed_types)}")
        return v


class ProvenanceEntity(ProvenanceEntityCreate):
    """Provenance entity with computed fields."""
    
    id: UUID
    record_id: UUID
    value_hash: str = Field(..., description="Hash of entity value for integrity")
    created_at: datetime
    
    class Config:
        from_attributes = True


class ProvenanceActivityCreate(BaseModel):
    """Create provenance activity request."""
    
    activity_type: str = Field(..., description="Type of activity")
    used_entities: List[str] = Field([], description="Entities used by this activity")
    generated_entities: List[str] = Field([], description="Entities generated by this activity")
    started_at: Optional[datetime] = Field(None, description="Activity start time")
    ended_at: Optional[datetime] = Field(None, description="Activity end time")
    attributes: Dict[str, Any] = Field({}, description="Activity attributes")
    location: Optional[str] = Field(None, description="Where the activity took place")
    
    @validator("activity_type")
    def validate_activity_type(cls, v):
        allowed_types = [
            "decision_generation", "data_collection", "model_training", "model_inference",
            "protocol_execution", "data_validation", "risk_assessment", "treatment_planning",
            "evidence_synthesis", "guideline_application", "manual_review", "automated_analysis"
        ]
        if v not in allowed_types:
            raise ValueError(f"Activity type must be one of: {', '.join(allowed_types)}")
        return v
    
    @validator("ended_at")
    def validate_end_time(cls, v, values):
        if v and values.get("started_at") and v < values["started_at"]:
            raise ValueError("End time cannot be before start time")
        return v


class ProvenanceActivity(ProvenanceActivityCreate):
    """Provenance activity with computed fields."""
    
    id: UUID
    record_id: UUID
    
    class Config:
        from_attributes = True


class ProvenanceAgentCreate(BaseModel):
    """Create provenance agent request."""
    
    agent_type: str = Field(..., description="Type of agent")
    agent_id: str = Field(..., description="Unique identifier of the agent")
    name: str = Field(..., description="Name of the agent")
    attributes: Dict[str, Any] = Field({}, description="Agent attributes")
    acted_on_behalf_of: Optional[str] = Field(None, description="Agent this agent acted on behalf of")
    
    @validator("agent_type")
    def validate_agent_type(cls, v):
        allowed_types = [
            "person", "software_agent", "organization", "device", "algorithm",
            "ai_model", "clinical_protocol", "guideline", "institution"
        ]
        if v not in allowed_types:
            raise ValueError(f"Agent type must be one of: {', '.join(allowed_types)}")
        return v


class ProvenanceAgent(ProvenanceAgentCreate):
    """Provenance agent with computed fields."""
    
    id: UUID
    record_id: UUID
    
    class Config:
        from_attributes = True


class ProvenanceCreate(BaseModel):
    """Create provenance record request."""
    
    namespace: str = Field(..., description="Namespace for the provenance record")
    prefix: str = Field(..., description="Prefix for identifiers")
    entities: List[ProvenanceEntityCreate] = Field(..., description="Entities in the provenance")
    activities: List[ProvenanceActivityCreate] = Field(..., description="Activities in the provenance")
    agents: List[ProvenanceAgentCreate] = Field(..., description="Agents in the provenance")
    bundle_id: Optional[str] = Field(None, description="Bundle identifier for grouping")
    derived_from: Optional[UUID] = Field(None, description="Provenance record this is derived from")
    revision_of: Optional[UUID] = Field(None, description="Provenance record this is a revision of")


class ProvenanceRecord(BaseModel):
    """Complete provenance record."""
    
    id: UUID
    user_id: UUID
    namespace: str
    prefix: str
    entities: List[ProvenanceEntity]
    activities: List[ProvenanceActivity]
    agents: List[ProvenanceAgent]
    bundle_id: Optional[str] = None
    derived_from: Optional[UUID] = None
    revision_of: Optional[UUID] = None
    ipfs_hash: Optional[str] = None
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True


class ProvenanceQuery(BaseModel):
    """Query parameters for provenance search."""
    
    entity_id: Optional[str] = Field(None, description="Find records containing this entity")
    entity_type: Optional[str] = Field(None, description="Find records with entities of this type")
    activity_type: Optional[str] = Field(None, description="Find records with activities of this type")
    agent_id: Optional[str] = Field(None, description="Find records involving this agent")
    agent_type: Optional[str] = Field(None, description="Find records with agents of this type")
    bundle_id: Optional[str] = Field(None, description="Find records in this bundle")
    time_range: Optional[Dict[str, datetime]] = Field(None, description="Time range filter")
    attributes: Optional[Dict[str, Any]] = Field(None, description="Attribute-based filters")
    limit: int = Field(100, ge=1, le=1000, description="Maximum number of results")
    offset: int = Field(0, ge=0, description="Number of results to skip")


class LineageNode(BaseModel):
    """Node in a data lineage graph."""
    
    id: str = Field(..., description="Node identifier")
    type: str = Field(..., description="Node type (entity, activity, agent)")
    label: str = Field(..., description="Human-readable label")
    attributes: Dict[str, Any] = Field({}, description="Node attributes")
    level: int = Field(0, description="Distance from root node")
    timestamp: Optional[datetime] = Field(None, description="Node timestamp")


class LineageEdge(BaseModel):
    """Edge in a data lineage graph."""
    
    source: str = Field(..., description="Source node ID")
    target: str = Field(..., description="Target node ID")
    relation: str = Field(..., description="Relationship type")
    attributes: Dict[str, Any] = Field({}, description="Edge attributes")
    weight: float = Field(1.0, description="Edge weight for visualization")


class LineageGraph(BaseModel):
    """Data lineage graph representation."""
    
    nodes: List[LineageNode] = Field(..., description="Graph nodes")
    edges: List[LineageEdge] = Field(..., description="Graph edges")
    metadata: Dict[str, Any] = Field({}, description="Graph metadata")


class ProvenanceTrailStep(BaseModel):
    """Step in a provenance trail."""
    
    entity_id: str = Field(..., description="Entity at this step")
    activity_id: Optional[str] = Field(None, description="Activity that created this step")
    agent_id: Optional[str] = Field(None, description="Agent responsible for this step")
    timestamp: datetime = Field(..., description="Step timestamp")
    confidence: float = Field(1.0, ge=0, le=1, description="Confidence in this step")
    attributes: Dict[str, Any] = Field({}, description="Step attributes")


class ProvenanceTrail(BaseModel):
    """Trail showing provenance path between entities."""
    
    start_entity: UUID = Field(..., description="Starting entity")
    end_entity: UUID = Field(..., description="Ending entity")
    path: List[ProvenanceTrailStep] = Field(..., description="Trail steps")
    confidence_score: float = Field(..., ge=0, le=1, description="Overall trail confidence")
    metadata: Dict[str, Any] = Field({}, description="Trail metadata")


class ImmutableSnapshot(BaseModel):
    """Immutable snapshot stored in IPFS."""
    
    id: UUID
    provenance_id: UUID
    ipfs_hash: str = Field(..., description="IPFS content hash")
    content_hash: str = Field(..., description="SHA-256 hash of content")
    size_bytes: int = Field(..., description="Snapshot size in bytes")
    created_at: datetime
    
    class Config:
        from_attributes = True


class DataQualityMetrics(BaseModel):
    """Data quality metrics derived from provenance."""
    
    completeness: float = Field(..., ge=0, le=1, description="Data completeness score")
    accuracy: float = Field(..., ge=0, le=1, description="Data accuracy score")
    consistency: float = Field(..., ge=0, le=1, description="Data consistency score")
    timeliness: float = Field(..., ge=0, le=1, description="Data timeliness score")
    lineage_depth: int = Field(..., ge=0, description="Depth of data lineage")
    verification_count: int = Field(..., ge=0, description="Number of verifications")
    last_updated: Optional[datetime] = Field(None, description="Last update timestamp")
    quality_score: float = Field(..., ge=0, le=1, description="Overall quality score")


class ProvenanceExport(BaseModel):
    """Provenance export format."""
    
    format: str = Field("PROV-JSON", description="Export format")
    bundle_id: str = Field(..., description="Bundle identifier")
    exported_at: datetime = Field(..., description="Export timestamp")
    records: List[ProvenanceRecord] = Field(..., description="Provenance records")
    metadata: Dict[str, Any] = Field({}, description="Export metadata")


class ProvenanceImport(BaseModel):
    """Provenance import request."""
    
    bundle_data: Dict[str, Any] = Field(..., description="Bundle data to import")
    validate_integrity: bool = Field(True, description="Validate data integrity")
    merge_strategy: str = Field("create_new", description="How to handle existing records")
    
    @validator("merge_strategy")
    def validate_merge_strategy(cls, v):
        allowed_strategies = ["create_new", "update_existing", "skip_existing", "merge"]
        if v not in allowed_strategies:
            raise ValueError(f"Merge strategy must be one of: {', '.join(allowed_strategies)}")
        return v


class ProvenanceVisualization(BaseModel):
    """Provenance visualization configuration."""
    
    graph_type: str = Field("directed", description="Graph type for visualization")
    layout_algorithm: str = Field("hierarchical", description="Layout algorithm")
    node_styling: Dict[str, Any] = Field({}, description="Node styling configuration")
    edge_styling: Dict[str, Any] = Field({}, description="Edge styling configuration")
    filters: Dict[str, Any] = Field({}, description="Visualization filters")
    
    @validator("graph_type")
    def validate_graph_type(cls, v):
        allowed_types = ["directed", "undirected", "mixed"]
        if v not in allowed_types:
            raise ValueError(f"Graph type must be one of: {', '.join(allowed_types)}")
        return v
    
    @validator("layout_algorithm")
    def validate_layout_algorithm(cls, v):
        allowed_algorithms = ["hierarchical", "force_directed", "circular", "tree", "grid"]
        if v not in allowed_algorithms:
            raise ValueError(f"Layout algorithm must be one of: {', '.join(allowed_algorithms)}")
        return v


class ProvenanceVerification(BaseModel):
    """Provenance verification result."""
    
    is_valid: bool = Field(..., description="Whether provenance is valid")
    verification_time: datetime = Field(..., description="Verification timestamp")
    errors: List[str] = Field([], description="Validation errors")
    warnings: List[str] = Field([], description="Validation warnings")
    signature_valid: bool = Field(True, description="Digital signature validity")
    hash_matches: bool = Field(True, description="Content hash validity")
    ipfs_accessible: bool = Field(True, description="IPFS content accessibility")


class ClinicalProvenanceTemplate(BaseModel):
    """Template for common clinical provenance patterns."""
    
    template_id: str = Field(..., description="Template identifier")
    name: str = Field(..., description="Template name")
    description: str = Field(..., description="Template description")
    entity_templates: List[Dict[str, Any]] = Field(..., description="Entity templates")
    activity_templates: List[Dict[str, Any]] = Field(..., description="Activity templates")
    agent_templates: List[Dict[str, Any]] = Field(..., description="Agent templates")
    required_fields: List[str] = Field([], description="Required fields for this template")
    
    @validator("template_id")
    def validate_template_id(cls, v):
        allowed_templates = [
            "clinical_decision", "treatment_plan", "medication_prescription",
            "diagnostic_test", "surgical_procedure", "patient_assessment",
            "protocol_execution", "guideline_application", "risk_assessment"
        ]
        if v not in allowed_templates:
            raise ValueError(f"Template ID must be one of: {', '.join(allowed_templates)}")
        return v


class ProvenanceStats(BaseModel):
    """Provenance system statistics."""
    
    total_records: int = Field(..., description="Total provenance records")
    total_entities: int = Field(..., description="Total entities tracked")
    total_activities: int = Field(..., description="Total activities recorded")
    total_agents: int = Field(..., description="Total agents involved")
    immutable_snapshots: int = Field(..., description="Total IPFS snapshots")
    average_lineage_depth: float = Field(..., description="Average lineage depth")
    data_quality_score: float = Field(..., ge=0, le=1, description="Overall data quality")
    verification_rate: float = Field(..., ge=0, le=1, description="Verification success rate")
    storage_efficiency: float = Field(..., ge=0, le=1, description="Storage efficiency")
    last_updated: datetime = Field(..., description="Last statistics update")
